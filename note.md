# 용어 정리

- 컴파일러(compiler), 인터프리터(interpreter): 프로그래밍 언어를 사용해 컴퓨터가 이해할 수 있는 기계어로 번역해주는 번역기 역할을 말한다.
- 리터럴(literal): 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
- 연산자(operator)
- 표현식(expression): 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- 문(statement): 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.
- 토큰(token): 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

## Node.js

- 비동기 I/O(input(입력)/output(출력))를 지원하며 단일 스레드 이벤트 루프 기반으로 동작하여 요청 처리 성능이 좋다.

## Javascript

- 웹브라우저에서 동작하는 유일한 프로그래밍 언어
- 컴파일 작업을 수행하지 않는 인터프리터 언어
- 명령형, 함수혀으 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

## 변수(variable)

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 값의 위치를 가리키는 상징적인 이름
- 할당(assignment): 변수에 값을 저장
- 참조(reference): 변수에 저장된 값을 읽어 들이는 것
- 상수(constant): 변수에 값이 재할당 되지 않는 경우, 변하지 않는 값

## 호이스팅(hoisting)

- 자바스크립트 엔진은 모든 선언문(변수 선언문, 함수 선언문 등)을 가장 먼저 실행한다.
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다.

## 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 단 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

## 표현식

- 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

## 데이터 타입

- 원시타입: 숫자, 문자열, 불리언, undefined, null, symbol() 타입
- 객체 타입: 객체, 함수, 배열 등
- NaN 도 숫자타입이다.
- 심벌(symbol)타입: 다른 값과 중복되지 않는 유일무이한 값.
- 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이를 동적 타이핑, 동적 타입 언어라고 한다.

## 연산자

- 문자열을 숫자로 타입 변환한다. ex) +'123456' // 123456
- NaN은 자신과 일치하지 않는 유일한 값이다. ex) NaN === NaN // false
- typeof null object를 반환하기 때문에 null 타입 확인은 일치 연산자(===)로 비교하는게 좋다.

## 레이블문

- 이중포문과 같은곳에서 내부문에서 break를 쓸 경우 내부포문만 종료되고 외부문은 빠져나가지 못하기 때문에 외부문에 레이블을 붙여 같이 빠져나갈 수 있게 된다.
- 코드가 복잡해지고 가독성 측면에서 좋지 않기 때문에 사용하는것을 권장하지 않는다.
- 레이블문 대신 이중 포문을 함수로 감싼 후 return을 통해 함수를 빠져나가는 방법이 더 좋아보임.

## falsy data

- 0, '', null, undefined, false, NaN

## 객체란?

- 원시 타입은 단 하나의 값만 나타내고 객체 타입은 다양한 타입의 값을 하나의 단위로 구성하는 복합적인 자료구조다.
- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 원시 값은 다른 변수에 할당하면 원시 값이 복사되어 전달된다. 이를 값에 의한 절달이라 한다. 객체는 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

## 인스턴스

- 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다.

## 객체 생성 방법

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

## 프로퍼티

- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.

## 얕은 복사, 깊은 복사

- 얕은 복사: 1단계만 복사
- 깊은 복사: 재귀적으로 원시값까지 전부 복사

## 함수

- 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정희한 것이다.
- 함수는 객체이다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
- 함수 선언문은 함수 이름을 생략할 수 없다.
- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

## 함수의 형태

- 즉시 실행 함수: 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다.
- 재귀 함수: 함수가 자기 자신을 호출하는 것을 재귀 호출이라 하고 재귀 호출을 수행하는 함수를 재귀라고 한다.
- 중첩 함수: 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 한다.
  중첩 함수를 포함하는 함수는 외부 함수라고 부른다.
- 콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다. 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다. 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다. 다시 말해 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

## 스코프

- 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.
- 렉시컬 환경: 코드가 어디서 실행되며 주변에 어떤 코드가 있는지
- 전역 변수는 어디서든지 참조할 수 있다.
- 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.
- 스코프 체인: 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
- 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.
- var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라 한다.
- 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.
  함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.

- 이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.

## 전역 변수 생명주기

- 호이스팅은 스코프를 단위로 동작한다.
- var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

## 전역 변수의 문제점

- 암묵적 결합
- 긴 생명 주기
- 스코프 체인 상에서 종점에 존재
- 네임스페이스 오염

## 전역 변수의 사용을 억제하는 방법

- 즉시 실행 함수
- 네임스페이스 객체
- 모듈 패턴

## let 키워드

- 변수 중복 선언 금지
- 블록 레벨 스코프
- let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행된다.

## const 키워드

- 변수 중복 선언, 재할당이 금지된 변수
- 블록 레벨 스코프
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
- 변수에 객체를 할당한 경우 값을 변경할 수 있다. 재할당을 금지할 뿐 "불변"을 의미하지는 않는다.

## 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

## 프로퍼티 상태

- [[Value]]: 값
- [[Writable]]: 값의 갱신 가능 여부(boolean)
- [[Enumerable]]: 열거 가능 여부(boolean)
- [[Configurable]]: 재정의 가능 여부(boolean)

## 객체 변경 방지

- 객체 확장 금지: 확장이 금지된 객체는 프로퍼티 추가가 금지된다.
- 객체 밀봉: 밀봉된 객체는 읽기와 쓰기만 가능하다.
- 객체 동결: 동결된 객체는 읽기만 가능하다.

## 생성자 함수

- new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.

## constructor, non-constructor

- constructor: 일반 함수 또는 생성자 함수로서 호출할 수 있는 객체 (함수 선언문, 함수 표현식, 클래스)
- non-constructor: 일반 함수로서만 호출할 수 있는 객체 (메서드, 화살표 함수)

## new.target

- new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.

## strict mode

- 전역에 strict mode 적용하는 것 피하기
- 함수 단위로 strict mode 적용하는 것 피하기

## strict mode가 발생시키는 에러

- 암묵적 전역
- 변수, 함수, 매개변수의 삭제
- 매개변수 이름의 중복
- with 문의 사용

## 빌트인 객체

- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다.

## this

- 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다. 이를 위해 자바스크립트는 this 라는 특수한 식별자를 제공한다.
- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.
- this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

## this 바인딩

- 일반 함수 호출: 기존적으로 this에는 전역 객체가 바인딩된다.
- 메서드 호출: 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표 연산자 앞에 기술한 객체가 바인딩된다.
- 생성자 함수 호출: 생성자 함수가 생성할 인스턴스가 바인딩된다.
- apply, call, bind: this를 명시적으로 지정할 수 있다.

## 실행 컨텍스트

- 실행 컨텍스트는 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
- 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경(정의 되어진 환경을 기준)으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.

## 클로저

- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 한다.
- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

## 렉시컬 스코프

- 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.
- 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다.

## class

- 정적 메서드는 인스턴스 생성없이 호출이 가능한 메서드.
- 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

## 클래스와 생성자 함수의 차이점

1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수를 new 연산자 없이 호출하면 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수 없다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 "Enumerable"의 값이 false이다. 열거되지 않는다.

## ES6

- 화살표 함수

1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 다.
2. 중복된 매개변수 이름을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

- Rest 파라미터: 함수에 전달된 인수들의 목록을 배열로 전달받는다.
- 매개변수 기본값
- 템플릿 리터럴
- 구조 분해 할당
- Promise
- class

## Array

- 자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.
- 자바스크립트는 희소배열을 허용하지만 희소 배열을 사용하지 않는 것이 좋다.

## 이터러블(iterable)

- 이터러블 프로토콜을 준수한 객체를 이터러블이라 한다. 이터러블은 for ...of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 상용할 수 있다.
- 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다. 이터레이터는 이터러블의 요소를 탐색하기 위한 포인터 역할을 한다.
- done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.
- 유사배열객체는 일반 객체이기 때문에 for ...of 문으로 순회할 수 없다.
- arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다.

## 스프레드 문법

- 스프레드 문법을 사용할 수 있는 대상은 이터러블에 한정된다.
- 스프레드 문법의 결과는 변수에 할당 할 수 없다.

## 구조 분해 할당(디스트럭처링)

- 베열 또는 객체를 디스트럭처링하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.
- 배열 디스트럭처링 할당의 대상(할당문의 우변)은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다.

## Set

- Set 객체는 중복되지 않는 유일한 값들의 집합이다.
- Set을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.
- Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.

## Map

- Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다.
- Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.
